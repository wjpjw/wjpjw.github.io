<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jipeng&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="wjpjw.github.io/"/>
  <updated>2016-09-01T04:35:42.000Z</updated>
  <id>wjpjw.github.io/</id>
  
  <author>
    <name>Jipeng Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高级微处理器架构</title>
    <link href="wjpjw.github.io/2016/09/01/adv-microarchitecture/"/>
    <id>wjpjw.github.io/2016/09/01/adv-microarchitecture/</id>
    <published>2016-09-01T04:35:09.000Z</published>
    <updated>2016-09-01T04:35:42.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="技术" scheme="wjpjw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="学术" scheme="wjpjw.github.io/tags/%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>大数据</title>
    <link href="wjpjw.github.io/2016/09/01/big-data/"/>
    <id>wjpjw.github.io/2016/09/01/big-data/</id>
    <published>2016-09-01T04:34:28.000Z</published>
    <updated>2016-09-01T04:34:46.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="技术" scheme="wjpjw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="学术" scheme="wjpjw.github.io/tags/%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>安全计算系统</title>
    <link href="wjpjw.github.io/2016/09/01/secure-computing-system/"/>
    <id>wjpjw.github.io/2016/09/01/secure-computing-system/</id>
    <published>2016-09-01T04:22:16.000Z</published>
    <updated>2016-09-01T22:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全计算系统的基本概念"><a href="#安全计算系统的基本概念" class="headerlink" title="安全计算系统的基本概念"></a>安全计算系统的基本概念</h1><h3 id="What-is-Computer-Security-gassbook-c1"><a href="#What-is-Computer-Security-gassbook-c1" class="headerlink" title="What is Computer Security(gassbook-c1)"></a>What is Computer Security(gassbook-c1)</h3><p>####SECRECY, INTEGRITY, AND DENIAL OF SERVICE</p>
<ol>
<li>Secrecy/Confidentiality：protecting the information from disclosure to unauthorized parties.</li>
<li>Integrity: protecting information from being modified by unauthorized parties.</li>
<li>Denial of service: 可能是机器故障导致信息损失。</li>
</ol>
<p>计算安全主要研究的是secrecy，信息不泄露。至于信息的integrity主要是指信息没被修改，实际上在商业软件中更常用，不过没多少研究者感兴趣，还好integrity需要的技术和secrecy差不多。至于denial of service虽然也是信息安全的话题，却不再讨论范围内，原因是软件正确性这一话题太难了，大多数情况下根本实现不了。</p>
<h4 id="可信系统评价标准"><a href="#可信系统评价标准" class="headerlink" title="可信系统评价标准"></a>可信系统评价标准</h4><p>美国国防部发布橙皮书：Trusted Computer System Evaluation Criteria，定义了安全概念。商用可以很容易通过加装一些addon达到C1或C2。只有军用才会追求A1或B3。<br><img src="/images/secure-level.png" alt="软件安全等级"></p>
<h3 id="Trusted-Computing"><a href="#Trusted-Computing" class="headerlink" title="Trusted Computing"></a>Trusted Computing</h3><h4 id="1-什么是TC"><a href="#1-什么是TC" class="headerlink" title="1. 什么是TC?"></a>1. 什么是TC?</h4><p>The Trusted Computing Group (TCG)是Microsoft, Intel, IBM, HP and AMD联合提出的更加安全的PC标准。这里安全的定义颇有争议。按TCG标准做的PC从微软、intel角度来看更可信，但对PC拥有者来说反而更不可信。TCG将你的控制权更多地转移给硬件、软件提供商。TC在这些公司叫法都不一样，故意让公众对此感到混淆。</p>
<h4 id="2-TC做的是什么？"><a href="#2-TC做的是什么？" class="headerlink" title="2. TC做的是什么？"></a>2. TC做的是什么？</h4><p>TC提供一个让你无权控制、更改软件的计算平台。动机源于digital rights management (DRM)。</p>
<p>TC使得如下可能成立，例如：</p>
<ol>
<li>卖一个只准拷贝三次的音乐。</li>
<li>必须24小时看完的电影，即租用软件。</li>
<li>禁止使用unlicensed software。</li>
<li>TC app可以互相依赖，non-TC app被各种歧视。</li>
<li>让政府部门创立的doc一创建就是classified，不会泄露。</li>
<li>远程审查，用traitor tracing的方式举报非法资源，远程删除某人机器上的音乐。</li>
<li>office可以用只有微软产品才能访问的秘钥，使得其他软件无法打开doc等。</li>
</ol>
<p>当然TC不会立刻让以前的东西用不了，会潜移默化，逐步实施。TC-PC必须比普通PC更好用，否则无法流行。</p>
<h4 id="3-TC是如何工作的"><a href="#3-TC是如何工作的" class="headerlink" title="3. TC是如何工作的?"></a>3. TC是如何工作的?</h4><p>TC为以后的PC提供一个监视与举报挂载组件。第一阶段的TC倾向于使用Fritz芯片——焊在主板上的智能芯片或dongle。当前的TC倾向于五个组件：</p>
<ol>
<li>Fritz芯片</li>
<li>CPU中的curtained memory机制</li>
<li>每个TC程序中的安全内核（微软称之为“NCA”）</li>
<li>一个操作系统安全内核（微软称之为“Nexus”）</li>
</ol>
<p>早期TC和Fritz监视boot进程，这样只要软硬件已知，PC最终会进入可预测的状态。</p>
<p>目前TC将Fritz作为一个消极监视组件，存储极其开始时的hash。这个hash用硬件细节来计算。如果机器最终进入了approved state，Fritz就会把TC密钥提供给操作系统。否则极其就无法获取TC密钥，只能跑non-TC程序，读non-TC数据。</p>
<p>Nexus桥接了Fritz和NCA，检查硬件组件是否在TCG认可名单里，软件是否已签约，序列号是否吊销了。如果PC配置有变，则机器联网重新认证这些信息。Nexus协作curtained memory阻止TC程序读写其他TC程序的数据。这种curtained memory机制在Intel中被称为Lagrande Technology，在AMD被成为TrustZone.</p>
<p>当机器在approved state运行TC程序时，Fritz会通过第三方，比如Disney，对copy的合法性进行认证。Disney服务器发送加密数据和密钥，Fritz只会把密钥提供给授权程序。这样整个环境就是trustworthy的。</p>
<h4 id="4-TC的利益相关"><a href="#4-TC的利益相关" class="headerlink" title="4. TC的利益相关"></a>4. TC的利益相关</h4><p>Disney等娱乐公司当然是最大受益方。</p>
<p>Intel垄断PC芯片，想要扩张，就要扩大PC市场，保证PC的DRM是避免PC地位下降的防守策略。</p>
<p>Microsoft可以得益于：</p>
<ol>
<li>卖出更多正版</li>
<li>增强用户黏性，提升换用其他软件的成本</li>
</ol>
<p>各种安全软件提供商会血崩。</p>
<p>有权利掌控TC基础设施的一方会拥有强大的独裁权力，可能被滥用。</p>
<h1 id="Design-principles-and-hardware-low-level-mechanisms"><a href="#Design-principles-and-hardware-low-level-mechanisms" class="headerlink" title="Design principles and hardware/low level mechanisms"></a>Design principles and hardware/low level mechanisms</h1><a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安全计算系统的基本概念&quot;&gt;&lt;a href=&quot;#安全计算系统的基本概念&quot; class=&quot;headerlink&quot; title=&quot;安全计算系统的基本概念&quot;&gt;&lt;/a&gt;安全计算系统的基本概念&lt;/h1&gt;&lt;h3 id=&quot;What-is-Computer-Security-gassbook-c1&quot;&gt;&lt;a href=&quot;#What-is-Computer-Security-gassbook-c1&quot; class=&quot;headerlink&quot; title=&quot;What is Computer Security(gassbook-c1)&quot;&gt;&lt;/a&gt;What is Computer Security(gassbook-c1)&lt;/h3&gt;&lt;p&gt;####SECRECY, INTEGRITY, AND DENIAL OF SERVICE&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Secrecy/Confidentiality：protecting the information from disclosure to unauthorized parties.&lt;/li&gt;
&lt;li&gt;Integrity: protecting information from being modified by unauthorized parties.&lt;/li&gt;
&lt;li&gt;Denial of service: 可能是机器故障导致信息损失。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;计算安全主要研究的是secrecy，信息不泄露。至于信息的integrity主要是指信息没被修改，实际上在商业软件中更常用，不过没多少研究者感兴趣，还好integrity需要的技术和secrecy差不多。至于denial of service虽然也是信息安全的话题，却不再讨论范围内，原因是软件正确性这一话题太难了，大多数情况下根本实现不了。&lt;/p&gt;
&lt;h4 id=&quot;可信系统评价标准&quot;&gt;&lt;a href=&quot;#可信系统评价标准&quot; class=&quot;headerlink&quot; title=&quot;可信系统评价标准&quot;&gt;&lt;/a&gt;可信系统评价标准&lt;/h4&gt;&lt;p&gt;美国国防部发布橙皮书：Trusted Computer System Evaluation Criteria，定义了安全概念。商用可以很容易通过加装一些addon达到C1或C2。只有军用才会追求A1或B3。&lt;br&gt;&lt;img src=&quot;/images/secure-level.png&quot; alt=&quot;软件安全等级&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Trusted-Computing&quot;&gt;&lt;a href=&quot;#Trusted-Computing&quot; class=&quot;headerlink&quot; title=&quot;Trusted Computing&quot;&gt;&lt;/a&gt;Trusted Computing&lt;/h3&gt;&lt;h4 id=&quot;1-什么是TC&quot;&gt;&lt;a href=&quot;#1-什么是TC&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是TC?&quot;&gt;&lt;/a&gt;1. 什么是TC?&lt;/h4&gt;&lt;p&gt;The Trusted Computing Group (TCG)是Microsoft, Intel, IBM, HP and AMD联合提出的更加安全的PC标准。这里安全的定义颇有争议。按TCG标准做的PC从微软、intel角度来看更可信，但对PC拥有者来说反而更不可信。TCG将你的控制权更多地转移给硬件、软件提供商。TC在这些公司叫法都不一样，故意让公众对此感到混淆。&lt;/p&gt;
&lt;h4 id=&quot;2-TC做的是什么？&quot;&gt;&lt;a href=&quot;#2-TC做的是什么？&quot; class=&quot;headerlink&quot; title=&quot;2. TC做的是什么？&quot;&gt;&lt;/a&gt;2. TC做的是什么？&lt;/h4&gt;&lt;p&gt;TC提供一个让你无权控制、更改软件的计算平台。动机源于digital rights management (DRM)。&lt;/p&gt;
&lt;p&gt;TC使得如下可能成立，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;卖一个只准拷贝三次的音乐。&lt;/li&gt;
&lt;li&gt;必须24小时看完的电影，即租用软件。&lt;/li&gt;
&lt;li&gt;禁止使用unlicensed software。&lt;/li&gt;
&lt;li&gt;TC app可以互相依赖，non-TC app被各种歧视。&lt;/li&gt;
&lt;li&gt;让政府部门创立的doc一创建就是classified，不会泄露。&lt;/li&gt;
&lt;li&gt;远程审查，用traitor tracing的方式举报非法资源，远程删除某人机器上的音乐。&lt;/li&gt;
&lt;li&gt;office可以用只有微软产品才能访问的秘钥，使得其他软件无法打开doc等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然TC不会立刻让以前的东西用不了，会潜移默化，逐步实施。TC-PC必须比普通PC更好用，否则无法流行。&lt;/p&gt;
&lt;h4 id=&quot;3-TC是如何工作的&quot;&gt;&lt;a href=&quot;#3-TC是如何工作的&quot; class=&quot;headerlink&quot; title=&quot;3. TC是如何工作的?&quot;&gt;&lt;/a&gt;3. TC是如何工作的?&lt;/h4&gt;&lt;p&gt;TC为以后的PC提供一个监视与举报挂载组件。第一阶段的TC倾向于使用Fritz芯片——焊在主板上的智能芯片或dongle。当前的TC倾向于五个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Fritz芯片&lt;/li&gt;
&lt;li&gt;CPU中的curtained memory机制&lt;/li&gt;
&lt;li&gt;每个TC程序中的安全内核（微软称之为“NCA”）&lt;/li&gt;
&lt;li&gt;一个操作系统安全内核（微软称之为“Nexus”）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;早期TC和Fritz监视boot进程，这样只要软硬件已知，PC最终会进入可预测的状态。&lt;/p&gt;
&lt;p&gt;目前TC将Fritz作为一个消极监视组件，存储极其开始时的hash。这个hash用硬件细节来计算。如果机器最终进入了approved state，Fritz就会把TC密钥提供给操作系统。否则极其就无法获取TC密钥，只能跑non-TC程序，读non-TC数据。&lt;/p&gt;
&lt;p&gt;Nexus桥接了Fritz和NCA，检查硬件组件是否在TCG认可名单里，软件是否已签约，序列号是否吊销了。如果PC配置有变，则机器联网重新认证这些信息。Nexus协作curtained memory阻止TC程序读写其他TC程序的数据。这种curtained memory机制在Intel中被称为Lagrande Technology，在AMD被成为TrustZone.&lt;/p&gt;
&lt;p&gt;当机器在approved state运行TC程序时，Fritz会通过第三方，比如Disney，对copy的合法性进行认证。Disney服务器发送加密数据和密钥，Fritz只会把密钥提供给授权程序。这样整个环境就是trustworthy的。&lt;/p&gt;
&lt;h4 id=&quot;4-TC的利益相关&quot;&gt;&lt;a href=&quot;#4-TC的利益相关&quot; class=&quot;headerlink&quot; title=&quot;4. TC的利益相关&quot;&gt;&lt;/a&gt;4. TC的利益相关&lt;/h4&gt;&lt;p&gt;Disney等娱乐公司当然是最大受益方。&lt;/p&gt;
&lt;p&gt;Intel垄断PC芯片，想要扩张，就要扩大PC市场，保证PC的DRM是避免PC地位下降的防守策略。&lt;/p&gt;
&lt;p&gt;Microsoft可以得益于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;卖出更多正版&lt;/li&gt;
&lt;li&gt;增强用户黏性，提升换用其他软件的成本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;各种安全软件提供商会血崩。&lt;/p&gt;
&lt;p&gt;有权利掌控TC基础设施的一方会拥有强大的独裁权力，可能被滥用。&lt;/p&gt;
&lt;h1 id=&quot;Design-principles-and-hardware-low-level-mechanisms&quot;&gt;&lt;a href=&quot;#Design-principles-and-hardware-low-level-mechanisms&quot; class=&quot;headerlink&quot; title=&quot;Design principles and hardware/low level mechanisms&quot;&gt;&lt;/a&gt;Design principles and hardware/low level mechanisms&lt;/h1&gt;
    
    </summary>
    
    
      <category term="技术" scheme="wjpjw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="学术" scheme="wjpjw.github.io/tags/%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>生活中的英语</title>
    <link href="wjpjw.github.io/2016/08/31/lexical-domain-extension/"/>
    <id>wjpjw.github.io/2016/08/31/lexical-domain-extension/</id>
    <published>2016-08-31T04:30:17.000Z</published>
    <updated>2016-09-01T04:27:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>词汇积累平时用quizlet，这里主要记一些日常生活里的词汇。</p>
<a id="more"></a>
<h3 id="汽车相关"><a href="#汽车相关" class="headerlink" title="汽车相关"></a>汽车相关</h3><table>
<thead>
<tr>
<th>中文</th>
<th>英文    </th>
</tr>
</thead>
<tbody>
<tr>
<td>备胎</td>
<td>spare tire</td>
</tr>
<tr>
<td>千斤顶</td>
<td>jack    </td>
</tr>
<tr>
<td>漏气轮胎</td>
<td>flat tire</td>
</tr>
<tr>
<td>拧螺丝的工具</td>
<td>tire iron或breaker bar</td>
</tr>
</tbody>
</table>
<h3 id="cs相关"><a href="#cs相关" class="headerlink" title="cs相关"></a>cs相关</h3><table>
<thead>
<tr>
<th>英文</th>
<th>读音</th>
</tr>
</thead>
<tbody>
<tr>
<td>x[1]</td>
<td>x sub one</td>
</tr>
<tr>
<td>multi-xxx</td>
<td>maotai-xxx</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;词汇积累平时用quizlet，这里主要记一些日常生活里的词汇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="常识" scheme="wjpjw.github.io/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>开始独立游戏开发</title>
    <link href="wjpjw.github.io/2016/08/31/independent-game-development/"/>
    <id>wjpjw.github.io/2016/08/31/independent-game-development/</id>
    <published>2016-08-31T04:00:07.000Z</published>
    <updated>2016-09-01T04:26:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>无论美术还是编程都让我乐在其中，既然如此，何不学习、探索独立游戏制作呢？</p>
<a id="more"></a>
<h2 id="绘画"><a href="#绘画" class="headerlink" title="绘画"></a>绘画</h2><p>之前一直觉得数控板很贵，的确贵，不过那是在屏幕上直接画的，只是板的话一点都不贵。我买了ugee ex07 graphic tablet，迅速上手。以我的天赋，学什么都很快，所以一定要努力，不可太懒散。</p>
<p>我发现shading还是太难了，看了不少youtube上的视频，真是需要磨练的，而且还费时间，所以我觉得可以不用考虑shading，直接描线+纯色上色，简单干净就好。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>购买了60美元的spine用来制作骨骼动画，免费的骨骼动画软件没有良好的编程API支持，尝试无效，还是spine好用。骨骼动画其实对美术要求不高，既方便又灵活，我觉得比完全碾压序列帧动画（Frame by frame）。</p>
<p>骨骼动画制作属于浪费时间的简单重复劳动。</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>目前唯一开源而且有人用的2d引擎是cocos2d，架构非常简单，功能也很少。unreal也是开源的，非常想尝试，不过目前cocos够用了，unreal以后再说吧。短期内我是不会涉足3d的，也不会有钱外包。</p>
<p>unity固然是更好的工具，但是为我所不喜。比如用cocos我可以只用其图形部分，自己实现一个python脚本引擎，然后c++加python做游戏，指定让自己舒服的标准与风格。</p>
<p>其他开源的游戏引擎用的人少，也就不存在特别方便的整合，也没有详实的文档。所以不会考虑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论美术还是编程都让我乐在其中，既然如此，何不学习、探索独立游戏制作呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="wjpjw.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="技术" scheme="wjpjw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Archlinux试玩</title>
    <link href="wjpjw.github.io/2016/08/30/archlinux/"/>
    <id>wjpjw.github.io/2016/08/30/archlinux/</id>
    <published>2016-08-31T03:52:42.000Z</published>
    <updated>2016-09-01T04:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Archlinux的安装是手动的，从中能学到一些东西，不过本质上与其他发行版是一样的，不涉及内核修改编译这种真正的定制。装了gnome后，和其他linux发行版感觉差不多。</p>
<a id="more"></a>
<h3 id="配置工具"><a href="#配置工具" class="headerlink" title="配置工具"></a>配置工具</h3><ol>
<li>dhcpcd：一个dhcp客户端。dhcp服务器一般就在局域网的路由器上，用于自动分配正确ip给各个机器。dhcpcd.conf里可以设置静态路由，hostname，static profile等。</li>
<li>启动或关闭服务：systemctl start/stop example.service</li>
<li>pacman：-Syy，同步数据库；-S elinks，安装elinks；-Ss xxx，搜索xxx；-R是删包。</li>
<li>fdisk或gdisk /dev/sda就可以进入partition界面，创建partition table。操作相当简单。</li>
<li>lsblk查看bulk device的挂载情况。</li>
<li>fstab配置挂载，locale.conf配置语言。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Archlinux的安装是手动的，从中能学到一些东西，不过本质上与其他发行版是一样的，不涉及内核修改编译这种真正的定制。装了gnome后，和其他linux发行版感觉差不多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="wjpjw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="常识" scheme="wjpjw.github.io/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C++的一种合理用法</title>
    <link href="wjpjw.github.io/2016/08/30/cpp-core-guideline/"/>
    <id>wjpjw.github.io/2016/08/30/cpp-core-guideline/</id>
    <published>2016-08-31T03:06:54.000Z</published>
    <updated>2016-09-01T04:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++是多范式的，即使是最传统的Better C或面向对象范式仍然有各种各样的风格，比如cocos2d的内存机制要求构造函数不throw，初始化代码放到init里，用addChild显式地制定对象所有权，若无对象拥有指针则在更新时自动析构。这么做非常安全。其实用raii+异常+unique_ptr可以做得同样好，而且更简洁。</p>
<p>不过每隔一段时间，我自己的观点也会变化，所以说这只是阶段性总结。<br><a id="more"></a></p>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ol>
<li>RAII+值语义是最方便的。所有权明确、生命周期明确、异常安全。依靠现代c++提供的各种值语义工具，自己的类大部分都可以实现值语义。</li>
<li>应该只允许存在const全局变量。单例也不要用。对全局变量的依赖会干扰判断，影响正确性分析。</li>
<li>使用异常。catch里面处理错误，看起来不美观，实际上还是比c风格清晰的。</li>
<li>函数参数应该用裸指针，对象own的成员用unique_ptr。裸指针表示引用，绝对不表示所有权转让。</li>
<li>接口类无状态，就是像java那样。不要用继承去实现代码复用，那只会增加强耦合代码。</li>
<li>可能异常的代码throw就好了，没必要catch，即使catch也只是按照不同异常进行log，不做补救，直接让系统crash掉。</li>
<li>保持简洁，能不写的就不写，比如不需要构造函数、析构函数，那就不写。需要暴露的变量，不写get/set，直接public。</li>
</ol>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol>
<li>纯c或纯c风格的函数缀上noexcept，表明无异常处理，可优化性能。</li>
<li>基类应该禁用拷贝构造函数，提供virtual的clone。clone返回owner<t*>, owner只用来表示这指针有所有权。</t*></li>
<li>虚函数应该明确指明virtual，override还是final。</li>
<li>使用enum class，不用enum，避免enum转型int这种可能性。</li>
<li>复杂变量初始化可以用lambda。</li>
<li>只要是值语义，就用unique_ptr<t>，不要用T本身，那样需要include类型T的头文件。</t></li>
<li>用vs的话，哪怕实际上编译时不需要，头文件也要include各种类型所在头文件，让静态分析立刻生效，避免语法错误。要知道，c++写错了编译一次又等半天，很痛苦。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++是多范式的，即使是最传统的Better C或面向对象范式仍然有各种各样的风格，比如cocos2d的内存机制要求构造函数不throw，初始化代码放到init里，用addChild显式地制定对象所有权，若无对象拥有指针则在更新时自动析构。这么做非常安全。其实用raii+异常+unique_ptr可以做得同样好，而且更简洁。&lt;/p&gt;
&lt;p&gt;不过每隔一段时间，我自己的观点也会变化，所以说这只是阶段性总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="日志" scheme="wjpjw.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="胡扯" scheme="wjpjw.github.io/tags/%E8%83%A1%E6%89%AF/"/>
    
  </entry>
  
  <entry>
    <title>奇奇怪怪的知识</title>
    <link href="wjpjw.github.io/2016/08/30/spicy-knowledge/"/>
    <id>wjpjw.github.io/2016/08/30/spicy-knowledge/</id>
    <published>2016-08-31T02:51:30.000Z</published>
    <updated>2016-09-01T15:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶尔更新一些无意中看到的冷门知识。</p>
<a id="more"></a>
<h3 id="阳光直射图"><a href="#阳光直射图" class="headerlink" title="阳光直射图"></a>阳光直射图</h3><p><img src="/images/irradiation.jpg" alt="果然国内的太阳温和很多"></p>
<h3 id="华人实现的语言"><a href="#华人实现的语言" class="headerlink" title="华人实现的语言"></a>华人实现的语言</h3><ol>
<li>ATS-PL-SYS: Hongwei Xi</li>
<li>F#: Tao Liu</li>
<li>sql: 刘英武</li>
<li>php: 惠新宸</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶尔更新一些无意中看到的冷门知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="常识" scheme="wjpjw.github.io/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>9月日志</title>
    <link href="wjpjw.github.io/2016/08/30/2016-9-log/"/>
    <id>wjpjw.github.io/2016/08/30/2016-9-log/</id>
    <published>2016-08-31T01:41:04.000Z</published>
    <updated>2016-09-01T17:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2016-8-30"><a href="#2016-8-30" class="headerlink" title="2016/8/30"></a>2016/8/30</h3><p>今天得主要目标是：</p>
<ol>
<li>搭建blog，hexo+atom，用md写日志。<em>——写了很多！</em></li>
<li>抽象cqscripts的游戏逻辑。<em>——写了一些，通过了stub测试！</em></li>
<li>研究adv. microarchitecture的project选题。<em>——哪有空，明天再说！</em></li>
</ol>
<p>目前看来几门课都很难，因此更要有计划，每天列出目标，狠狠地执行。</p>
<p>最近做菜放油，狂吃碳水化合物，怒喝汽水，完全不锻炼身体，反而变瘦了，估计是饮食随意，摄入的热量偏低。</p>
<a id="more"></a>
<h3 id="2016-8-31"><a href="#2016-8-31" class="headerlink" title="2016/8/31"></a>2016/8/31</h3><p>经过研究，发现研究adv. microarchitecture的project选题中，我选择了PIM Cache Replacement Optimization。这门课的选题非常前沿，除了这个话题以外，其他的课题很难找到两篇以上的论文。Cache replacement optimization则是经典话题。</p>
<p>之前名字差不多的课用C++写过模拟，这门课要用更真实的模拟框架，即SST。这门课老师带队做的MacSim是sst里面的一个component。MacSim是trace-driven cycle-level的异构模拟器，能够为异构提供timing model。这种为论文而产生的工具大多不靠谱，好在老师就是作者，出问题可以很方便地问。</p>
<p>此外，我发现secure computing system不需要课堂参与，但需要海量阅读，我需要在这周花大量时间阅读、整理，不懂的发邮件询问。加油！</p>
<p>今天得主要目标是：</p>
<ol>
<li>继续写游戏，能写多少是多少。</li>
<li>开始做医疗项目，不需要花太多时间，有进度即可。</li>
<li>刷算法题，能写多少是多少。</li>
</ol>
<p><em>很遗憾今天所有目标都没达成，看了一部纪录片the Chinese Mayor和一部cg电影，然后就12点了！</em></p>
<h3 id="2016-9-1"><a href="#2016-9-1" class="headerlink" title="2016/9/1"></a>2016/9/1</h3><p>目标：</p>
<ol>
<li>做医疗项目。不hangout，在slack上报告进度。</li>
<li>怒写游戏逻辑，能写多少是多少。</li>
<li>整理secure computing system的week1~3之全部。</li>
<li>怒刷算法。</li>
</ol>
<p>结果：<br>1.</p>
<ol>
<li>删去触发器机制，重构代码，添加一个package“data”，以python dict形式写配置文件。<br>3.<br>4.</li>
</ol>
<p>python的import的本质上是执行代码，def里面的东西暂未定义不妨碍def。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2016-8-30&quot;&gt;&lt;a href=&quot;#2016-8-30&quot; class=&quot;headerlink&quot; title=&quot;2016/8/30&quot;&gt;&lt;/a&gt;2016/8/30&lt;/h3&gt;&lt;p&gt;今天得主要目标是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搭建blog，hexo+atom，用md写日志。&lt;em&gt;——写了很多！&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;抽象cqscripts的游戏逻辑。&lt;em&gt;——写了一些，通过了stub测试！&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;研究adv. microarchitecture的project选题。&lt;em&gt;——哪有空，明天再说！&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前看来几门课都很难，因此更要有计划，每天列出目标，狠狠地执行。&lt;/p&gt;
&lt;p&gt;最近做菜放油，狂吃碳水化合物，怒喝汽水，完全不锻炼身体，反而变瘦了，估计是饮食随意，摄入的热量偏低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="wjpjw.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>使用Python作C++游戏的脚本</title>
    <link href="wjpjw.github.io/2016/08/30/boost-python/"/>
    <id>wjpjw.github.io/2016/08/30/boost-python/</id>
    <published>2016-08-30T23:20:00.000Z</published>
    <updated>2016-09-01T04:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Boost/python是无缝桥接cpp与python的最好工具。只需“exec某些python文件”，“写入读取python的全局变量”，”将c++类与函数以module形式提供给python”这3个功能就足以实现一个脚本引擎。</p>
<a id="more"></a>
<h3 id="脚本引擎架构设计"><a href="#脚本引擎架构设计" class="headerlink" title="脚本引擎架构设计"></a>脚本引擎架构设计</h3><ul>
<li>游戏加载时的init，每帧的update以及用户触摸点击事件touched。这三处可以执行对应的三个python文件，将控制权转交脚本。</li>
<li>c++应该专注实现图形相关的内容，提供的抽象全部基于图形，与游戏逻辑无关。python实现游戏逻辑，比如Unit是python中的纯逻辑对象，只不过创建它时存储了c++中包含骨骼动画的SkeletonUnit指针地址，和图形对象绑定了。</li>
<li>c++应该把图形相关的类、类函数、计算密集的函数导出，提供给python。python再浅包装一下c++暴露的原始接口，提供文档和默认参数，方便python开发、测试。</li>
</ul>
<h3 id="boost-python的细节"><a href="#boost-python的细节" class="headerlink" title="boost/python的细节"></a>boost/python的细节</h3><ul>
<li>并不是所有类都可以作为python对象的，很多类都delete掉了拷贝构造函数，这种类不能导出到python模块里，需要另写一个简单的代理类。</li>
<li>导出时随便def多少函数、变量，不影响类结构的完整导出。一个类如果所有成员变量类型都对python解释器已知，即使不导出任何方法也是可以作为python对象存储所有数据的。</li>
<li>def的所有函数在python看来都是不正常的，无参数默认值，无形参，所以最好在python里包装一下顺便写个文档。</li>
<li>所有c++对象转python对象都是根据指针进行一层deep copy，把指针所指的数据复制，但不会把对象里的指针层层复制。</li>
<li>想要把指针类型转化为python object，最好不用ptr()函数，而是用reinterpret_cast<int>。</int></li>
<li>win_sdk中定义了ssize_t，py_config.h里又define了一下，两者不统一，前者是long，后者是int，在windows下int和long等价，所以编译boost/python时要改python源码，只一处而已，问题不大。</li>
</ul>
<h3 id="为何要使用脚本"><a href="#为何要使用脚本" class="headerlink" title="为何要使用脚本"></a>为何要使用脚本</h3><p>现代c++非常强大，连lambda支持都完爆python，黑科技无穷无尽，写起来其实相当方便，但仍有一些缺点：</p>
<ul>
<li>c++需要VS或XCode支持。其他环境，例如武装到牙齿的emacs对复杂的c++项目依旧无力，IDE的整合是必需的。VS现在做的非常好用，但是特别笨重，又慢又占内存。不像编辑器打开了就写，随时随地的碎片时间可以利用起来。</li>
<li>c++随便改几句，编译一下就要几分钟甚至半小时。这导致无论开发还是debug都极其痛苦。脚本语言支持的热更新不仅方便了玩家，也节约了开发者的时间。</li>
<li>c++的方便高效建立在合理使用基础之上，门槛很高。即使合理使用了，还是有”声明”的额外书写代价，所以总归比脚本语言慢一些。</li>
</ul>
<h3 id="Python语言作脚本的优缺点"><a href="#Python语言作脚本的优缺点" class="headerlink" title="Python语言作脚本的优缺点"></a>Python语言作脚本的优缺点</h3><p>优点：</p>
<ul>
<li>JS，Lua都没有完备的类，与c++的逻辑绑定需要额外抽象成本。</li>
<li>JS其实很好，然而V8不支持ios设备。Boost/python支持各平台。</li>
<li>Python可以很方便地序列化。</li>
<li>Python作为抽象工具比较方便，语法甜，轮子也多。</li>
<li>layout控制语法，看起来清爽。</li>
</ul>
<p>缺点：</p>
<ul>
<li>计算性能低：V8&gt;Lua&gt;Python。</li>
<li>layout控制语法的设计会导致歧义、无法压缩脚本、修改代码时的麻烦。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Boost/python是无缝桥接cpp与python的最好工具。只需“exec某些python文件”，“写入读取python的全局变量”，”将c++类与函数以module形式提供给python”这3个功能就足以实现一个脚本引擎。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="wjpjw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
